package com.nike.wingtips;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;

/**
 * Represents some logical "unit of work" that is part of the larger distributed trace. A given request's trace tree is made up of all the spans with the same {@link #traceId}
 * and the spans are connected via parent-child relationship. The first span in the trace tree covers the entire distributed trace - it is often referred to as the root span.
 * <p/>
 * For any given service call in a distributed trace there is usually one span covering the full call; that service-level span is started when a request first hits the service
 * and {@link #complete()} is called when the response is sent to the caller, and at that point the resulting completed span is logged or otherwise sent to a span collector
 * of some sort so the span's data can be used later for investigations/aggregations/statistics.
 * <p/>
 * Extra "sub-spans" can be generated by a service if it wants additional tracing around specific functions inside the service. One sub-span example might be to create a sub-span
 * in service A when it makes a downstream call to service B. You could then subtract {@link #getTimeSpentNanos()} for service B's service-level span from the time spent in
 * service A's downstream call span to determine what the network lag was for that call.
 *
 * @author Nic Munroe
 */
public class Span {

    private static final Logger logger = LoggerFactory.getLogger(Span.class);

    /** The name of the trace ID field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getTraceId()}. */
    public static final String TRACE_ID_FIELD = "traceId";
    /** The name of the parent span ID field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getParentSpanId()}. */
    public static final String PARENT_SPAN_ID_FIELD = "parentSpanId";
    /** The name of the span ID field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getSpanId()}. */
    public static final String SPAN_ID_FIELD = "spanId";
    /** The name of the span name field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getSpanName()}. */
    public static final String SPAN_NAME_FIELD = "spanName";
    /** The name of the sampleable field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #isSampleable()}. */
    public static final String SAMPLEABLE_FIELD = "sampleable";
    /** The name of the user ID field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getUserId()}. */
    public static final String USER_ID_FIELD = "userId";
    /** The name of the start-time-in-nanos field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getSpanStartTimeNanos()}. */
    public static final String START_TIME_NANOS_FIELD = "startTimeNanos";
    /** The name of the end-time-in-nanos field when serializing/deserializing to/from JSON (see {@link #toJSON()} and {@link #fromJSON(String)}). Corresponds to {@link #getSpanEndTimeNanos()}. */
    public static final String END_TIME_NANOS_FIELD = "endTimeNanos";
    /** The name of the time-spent-in-nanos field when serializing to JSON (see {@link #toJSON()}. Corresponds to {@link #getTimeSpentNanos()}. */
    public static final String TIME_SPENT_NANOS_FIELD = "timeSpentNanos";

    private final String traceId;
    private final String spanId;
    private final String parentSpanId;
    private final String spanName;
    private final boolean sampleable;
    private final String userId;
    private final long spanStartTimeNanos;
    private Long spanEndTimeNanos;

    private Long timeSpentNanos;

    private String cachedJsonRepresentation;

    private String cachedKeyValueRepresentation;

    /**
     * The full constructor allowing you to set all fields representing a span's state. The traceId, spanId, and spanName fields cannot be null (an {@link IllegalArgumentException}
     * will be thrown if any are null). This method is public to allow full flexibility, however in practice you should use one of the provided
     * {@link #generateRootSpanForNewTrace(String)} or {@link #generateChildSpan(String)} helper methods, or the {@link Builder} if you need more flexibility than
     * the helper methods.
     */
    public Span(String traceId, String parentSpanId, String spanId, String spanName, boolean sampleable, String userId, long spanStartTimeNanos, Long spanEndTimeNanos) {
        if (traceId == null)
            throw new IllegalArgumentException("traceId cannot be null");

        if (spanId == null)
            throw new IllegalArgumentException("spanId cannot be null");

        if (spanName == null)
            throw new IllegalArgumentException("spanName cannot be null");

        this.traceId = traceId;
        this.spanId = spanId;
        this.parentSpanId = parentSpanId;
        this.spanName = spanName;
        this.sampleable = sampleable;
        this.userId = userId;
        this.spanStartTimeNanos = spanStartTimeNanos;
        this.spanEndTimeNanos = spanEndTimeNanos;

        // If spanEndTimeNanos is not null then we need to set timeSpentNanos here because the complete() method may never be called
        // (e.g. when manually deserializing a span that was completed and serialized sometime in the past).
        if (spanEndTimeNanos != null) {
            if (spanEndTimeNanos < spanStartTimeNanos)
                throw new IllegalArgumentException("Span end time cannot be before start time");

            this.timeSpentNanos = spanEndTimeNanos - spanStartTimeNanos;
        }
    }

    // For deserialization only - this will create an invalid span object and is only here to support deserializers that need a default constructor but set the fields directly (e.g. Jackson)
    protected Span() {
        this("PLACEHOLDER", null, "PLACEHOLDER", "PLACEHOLDER", false, null, -1, null);
    }

    /**
     * @return A builder setup to generate an uncompleted root span for a new trace. Since it is a root span it will have a null {@link #getParentSpanId()}. If no further changes are
     *          made to the returned builder then when {@link Builder#build()} is called the resulting span's {@link #getTraceId()} and {@link #getSpanId()} will be randomly
     *          generated and {@link #getSpanStartTimeNanos()} will be set to the {@link System#nanoTime()} value when {@link Builder#build()} is called. If further tweaks
     *          to the span are necessary you can adjust the builder before calling {@link Builder#build()} (e.g. setting a user ID via {@link Builder#withUserId(String)}.
     */
    public static Builder generateRootSpanForNewTrace(String spanName) {
        return Span.newBuilder(spanName);
    }

    /**
     * @return A new uncompleted span representing a child of this instance. The returned instance's {@link #getParentSpanId()} will be this instance's {@link #getSpanId()}, its
     *          {@link #getSpanName()} will be the given value, its {@link #getSpanId()} will be randomly generated, and its {@link #getSpanStartTimeNanos()} will be
     *          set to {@link System#nanoTime()}. It will share this instance's {@link #getTraceId()}, {@link #isSampleable()}, and {@link #getUserId()} values.
     */
    public Span generateChildSpan(String spanName) {
        return Span.newBuilder(this)
                   .withParentSpanId(this.spanId)
                   .withSpanName(spanName)
                   .withSpanId(TraceAndSpanIdGenerator.generateId())
                   .withSpanStartTimeNanos(System.nanoTime())
                   .withSpanEndTimeNanos(null)
                   .build();
    }

    /**
     * @return A new span builder with nothing populated beyond the given span name. Based on the behavior of {@link Builder#build()}, if you were to build it immediately you'd
     *          end up with an uncompleted root span for a new trace (same behavior as {@link #generateRootSpanForNewTrace(String)}). You are free to adjust any values before
     *          building however, so you can setup the builder to represent any span you want.
     */
    public static Builder newBuilder(String spanName) {
        return new Builder(spanName);
    }

    /**
     * @return A new span builder that has all its fields copied from the given {@link Span}. If you call {@link Builder#build()} immediately on the returned builder you'd
     *          end up with an exact duplicate of the given span.
     */
    public static Builder newBuilder(Span copy) {
        Builder builder = new Builder(copy.spanName);
        builder.spanEndTimeNanos = copy.spanEndTimeNanos;
        builder.traceId = copy.traceId;
        builder.spanId = copy.spanId;
        builder.parentSpanId = copy.parentSpanId;
        builder.sampleable = copy.sampleable;
        builder.userId = copy.userId;
        builder.spanStartTimeNanos = copy.spanStartTimeNanos;
        return builder;
    }

    /**
     * @return The ID associated with the overall distributed trace - a.k.a. the trace tree ID. All spans in a distributed trace will share the same trace ID.
     *          Don't confuse this with {@link #getSpanId()}, which is the ID for an individual span of work as part of the larger distributed trace. This will never
     *          be null.
     */
    public String getTraceId() {
        return traceId;
    }

    /**
     * @return The ID for this span of work in the distributed trace. Don't confuse this with the {@link #getTraceId()}, which is the ID associated with the overall
     *          distributed trace and is the same for all spans in a trace. Also don't confuse this with {@link #getParentSpanId()}, which is the ID of the span that spawned
     *          this span instance (the logical "parent" of this span). This will never be null.
     */
    public String getSpanId() {
        return spanId;
    }

    /**
     * @return The ID of the span that spawned this span instance (the logical "parent" of this span), or null if no such parent exists. If this returns null then this
     *          span is the "root span" for the distributed trace - the ultimate ancestor of all other spans in the trace tree.
     */
    public String getParentSpanId() {
        return parentSpanId;
    }

    /**
     * @return The human-readable name for this span. This will never be null.
     */
    public String getSpanName() {
        return spanName;
    }

    /**
     * @return True if this span is sampleable and should be output to the logging/span collection system, false otherwise.
     */
    public boolean isSampleable() {
        return sampleable;
    }

    /**
     * @return The ID of the user logically associated with this span, or null if no such user ID exists or is appropriate.
     */
    public String getUserId() {
        return userId;
    }

    /**
     * @return The start time of the span - calculated by calling {@link System#nanoTime()} when the constructor for this instance was called.
     */
    public long getSpanStartTimeNanos() {
        return spanStartTimeNanos;
    }

    /**
     * Indicates that this {@link Span} is completed/finished/finalized and sets {@link #getSpanEndTimeNanos()} to be {@link System#nanoTime()}. After this is called
     * then {@link #isCompleted()} will return true and {@link #getTimeSpentNanos()} will be set to the difference between {@link #getSpanEndTimeNanos()} and
     * {@link #getSpanStartTimeNanos()}.
     * <p/>
     * NOTE: This is intentionally package scoped to make sure completions and logging/span output logic happens centrally through {@link Tracer}.
     */
    void complete() {
        this.spanEndTimeNanos = System.nanoTime();
        this.timeSpentNanos = spanEndTimeNanos - spanStartTimeNanos;
        // We need to recalculate the JSON and/or key/value representation(s) of this span now that the state of the span has been modified.
        // By setting a cached value to null it will be regenerated the next time it is requested.
        cachedJsonRepresentation = null;
        cachedKeyValueRepresentation = null;
    }

    /**
     * @return true if {@link #complete()} has been called on this instance (representing a completed/finished/finalized span), false otherwise.
     */
    public boolean isCompleted() {
        return spanEndTimeNanos != null;
    }

    /**
     * @return {@link #spanEndTimeNanos} if {@link #complete()} has been called, or null if {@link #complete()} has not yet been called.
     */
    public Long getSpanEndTimeNanos() {
        return spanEndTimeNanos;
    }

    /**
     * @return The amount of time in nanoseconds between when this span was started and when it was completed - this will return null if {@link #isCompleted()} is false.
     *          You must call {@link #complete()} to complete the span and populate the field this method returns.
     */
    public Long getTimeSpentNanos() {
        return timeSpentNanos;
    }

    /**
     * @return The JSON representation of this span. See {@link #toJSON()}.
     */
    @Override
    public String toString() {
        return toJSON();
    }

    /**
     * @return A comma-delimited {@code key=value} string based on this {@link Span} instance.
     *         NOTE: {@link #END_TIME_NANOS_FIELD} and {@link #TIME_SPENT_NANOS_FIELD} fields will be added only if {@link #isCompleted()} is true. This lets you call this method
     *         at any time and only the relevant data will be output in the returned String (e.g. in case you want to log info about the span before it has been completed).
     */
    public String toKeyValueString() {
        if (cachedKeyValueRepresentation == null)
            cachedKeyValueRepresentation = calculateKeyValueString();

        return cachedKeyValueRepresentation;
    }

    /**
     * Calculates and returns the key=value representation of this span instance.
     */
    protected String calculateKeyValueString() {
        StringBuilder builder = new StringBuilder();

        builder.append(TRACE_ID_FIELD).append("=").append(traceId).append(",");
        builder.append(PARENT_SPAN_ID_FIELD).append("=").append(parentSpanId).append(",");
        builder.append(SPAN_ID_FIELD).append("=").append(spanId).append(",");
        builder.append(SPAN_NAME_FIELD).append("=").append(spanName).append(",");
        builder.append(SAMPLEABLE_FIELD).append("=").append(sampleable).append(",");
        builder.append(USER_ID_FIELD).append("=").append(userId).append(",");
        builder.append(START_TIME_NANOS_FIELD).append("=").append(spanStartTimeNanos);
        if (isCompleted()) {
            builder.append(",");
            builder.append(END_TIME_NANOS_FIELD).append("=").append(spanEndTimeNanos).append(",");
            builder.append(TIME_SPENT_NANOS_FIELD).append("=").append(timeSpentNanos);
        }

        return builder.toString();
    }

    /**
     * @return The {@link Span} represented by the given key/value string. <b>WARNING:</b> This method assumes the string you're trying to deserialize originally came from
     *          {@link #toKeyValueString()}. This assumption allows it to be as fast as possible, not worry about syntactically-correct-but-annoying-to-deal-with whitespace,
     *          not have to use a third party utility, etc.
     */
    public static Span fromKeyValueString(String keyValueStr) {
        try {
            // Create a map of keys to values.
            Map<String, String> map = new HashMap<>();

            // Split on the commas that separate the key/value pairs.
            String[] fieldPairs = keyValueStr.split(",");
            for (String fieldPair : fieldPairs) {
                // Split again on the equals character that separate the field's key from its value.
                String[] keyVal = fieldPair.split("=");
                map.put(keyVal[0], keyVal[1]);
            }

            return fromKeyValueMap(map);
        } catch (Exception e) {
            logger.error("Error extracting Span from key/value string. Defaulting to null. bad_span_key_value_string={}", keyValueStr, e);
            return null;
        }
    }

    /**
     * @return A JSON string based on this {@link Span} instance.
     *         NOTE: {@link #END_TIME_NANOS_FIELD} and {@link #TIME_SPENT_NANOS_FIELD} fields will be added only if {@link #isCompleted()} is true. This lets you call this method
     *         at any time and only the relevant data will be output in the returned JSON (e.g. in case you want to log info about the span before it has been completed).
     */
    public String toJSON() {
        // Profiling shows this JSON creation to generate a lot of garbage in certain situations, so we should cache the result.
        if (cachedJsonRepresentation == null)
            cachedJsonRepresentation = calculateJson();

        return cachedJsonRepresentation;
    }

    /**
     * Calculates and returns the JSON representation of this span instance. We build this manually ourselves to avoid pulling in an extra dependency (e.g. Jackson) just for
     * building a simple JSON string.
     */
    protected String calculateJson() {
        StringBuilder builder = new StringBuilder();

        builder.append("{\"" + TRACE_ID_FIELD + "\":\"").append(traceId);
        builder.append("\",\"" + PARENT_SPAN_ID_FIELD + "\":\"").append(parentSpanId);
        builder.append("\",\"" + SPAN_ID_FIELD + "\":\"").append(spanId);
        builder.append("\",\"" + SPAN_NAME_FIELD + "\":\"").append(spanName);
        builder.append("\",\"" + SAMPLEABLE_FIELD + "\":\"").append(sampleable);
        builder.append("\",\"" + USER_ID_FIELD + "\":\"").append(userId);
        builder.append("\",\"" + START_TIME_NANOS_FIELD + "\":\"").append(spanStartTimeNanos);
        if (isCompleted()) {
            builder.append("\",\"" + END_TIME_NANOS_FIELD + "\":\"").append(spanEndTimeNanos);
            builder.append("\",\"" + TIME_SPENT_NANOS_FIELD + "\":\"").append(timeSpentNanos);
        }
        builder.append("\"}");

        return builder.toString();
    }

    /**
     * @return The {@link Span} represented by the given JSON string. <b>WARNING:</b> This method assumes the JSON you're trying to deserialize originally came from {@link #toJSON()}.
     *          This assumption allows it to be as fast as possible, not have to check for malformed JSON, not worry about syntactically-correct-but-annoying-to-deal-with whitespace,
     *          not have to use a third party utility like Jackson, etc.
     */
    public static Span fromJSON(String json) {
        try {
            // Create a map of JSON field keys to values.
            Map<String, String> map = new HashMap<>();

            // Strip off the {" and "} at the beginning/end.
            String innerJsonCore = json.substring(2, json.length() - 2);
            // Split on the doublequotes-comma-doublequotes that separate the fields.
            String[] fieldPairs = innerJsonCore.split("\",\"");
            for (String fieldPair : fieldPairs) {
                // Split again on the doublequotes-colon-doublequotes that separate the field's key from its value. At this point all double-quotes have been stripped off
                // and we can just map the key to the value.
                String[] keyVal = fieldPair.split("\":\"");
                map.put(keyVal[0], keyVal[1]);
            }

            return fromKeyValueMap(map);
        } catch (Exception e) {
            logger.error("Error extracting Span from JSON. Defaulting to null. bad_span_json={}", json, e);
            return null;
        }
    }

    private static Span fromKeyValueMap(Map<String, String> map) {
        // Use the map to get the field values for the span.
        String traceId = nullSafeGetString(map, TRACE_ID_FIELD);
        String spanId = nullSafeGetString(map, SPAN_ID_FIELD);
        String parentSpanId = nullSafeGetString(map, PARENT_SPAN_ID_FIELD);
        String spanName = nullSafeGetString(map, SPAN_NAME_FIELD);
        Boolean sampleable = nullSafeGetBoolean(map, SAMPLEABLE_FIELD);
        if (sampleable == null)
            throw new IllegalStateException("Unable to parse " + SAMPLEABLE_FIELD + " from JSON");
        String userId = nullSafeGetString(map, USER_ID_FIELD);
        Long startTimeNanos = nullSafeGetLong(map, START_TIME_NANOS_FIELD);
        if (startTimeNanos == null)
            throw new IllegalStateException("Unable to parse " + START_TIME_NANOS_FIELD + " from JSON");
        Long endTimeNanos = nullSafeGetLong(map, END_TIME_NANOS_FIELD);
        return new Span(traceId, parentSpanId, spanId, spanName, sampleable, userId, startTimeNanos, endTimeNanos);
    }

    private static String nullSafeGetString(Map<String, String> map, String key) {
        String value = map.get(key);
        if (value == null || value.equals("null"))
            return null;

        return value;
    }

    private static Long nullSafeGetLong(Map<String, String> map, String key) {
        String value = nullSafeGetString(map, key);
        if (value == null)
            return null;

        return Long.parseLong(value);
    }

    private static Boolean nullSafeGetBoolean(Map<String, String> map, String key) {
        String value = nullSafeGetString(map, key);
        if (value == null)
            return null;

        return Boolean.parseBoolean(value);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof Span))
            return false;

        Span span = (Span) o;

        if (!spanId.equals(span.spanId))
            return false;
        if (sampleable != span.sampleable)
            return false;
        if (spanStartTimeNanos != span.spanStartTimeNanos)
            return false;
        if (!traceId.equals(span.traceId))
            return false;
        if (parentSpanId != null ? !parentSpanId.equals(span.parentSpanId) : span.parentSpanId != null)
            return false;
        if (!spanName.equals(span.spanName))
            return false;
        if (userId != null ? !userId.equals(span.userId) : span.userId != null)
            return false;
        //noinspection RedundantIfStatement
        if (spanEndTimeNanos != null ? !spanEndTimeNanos.equals(span.spanEndTimeNanos) : span.spanEndTimeNanos != null)
            return false;

        return true;

    }

    @Override
    public int hashCode() {
        int result = traceId.hashCode();
        result = 31 * result + spanId.hashCode();
        result = 31 * result + (parentSpanId != null ? parentSpanId.hashCode() : 0);
        result = 31 * result + spanName.hashCode();
        result = 31 * result + (sampleable ? 1 : 0);
        result = 31 * result + (userId != null ? userId.hashCode() : 0);
        result = 31 * result + (int) (spanStartTimeNanos ^ (spanStartTimeNanos >>> 32));
        result = 31 * result + (spanEndTimeNanos != null ? spanEndTimeNanos.hashCode() : 0);
        return result;
    }

    /**
     * Builder for creating {@link Span} objects.
     * <p/>
     * IMPORTANT NOTE: Calling {@link #build()} will choose sensible defaults for {@code traceId} and {@code spanId} if they are null when {@link #build()} is called by
     *                 calling {@link TraceAndSpanIdGenerator#generateId()} for each, and will default {@code spanStartTimeNanos} to {@link System#nanoTime()}.
     *                 This allows you to generate a fresh "root" span by creating a new instance of this builder and immediately calling {@link #build()}
     *                 without any further parameters being set. The simplest way to generate a child span is to get your hands on the parent span and call
     *                 {@link Span#generateChildSpan(String)} rather than use this builder directly. For any other use cases you can use this builder to set any
     *                 {@link Span} fields you want manually.
     */
    public static final class Builder {
        private String traceId;
        private String spanId;
        private String parentSpanId;
        private String spanName;
        private boolean sampleable = true;
        private String userId;
        private Long spanStartTimeNanos;
        private Long spanEndTimeNanos;

        private Builder(String spanName) {
            this.spanName = spanName;
        }

        /**
         * Sets the The ID associated with the overall distributed trace - a.k.a. the trace tree ID. All spans in a distributed trace will share the same trace ID.
         * Don't confuse this with {@link #withSpanId(String)}, which sets the ID for an individual span of work as part of the larger distributed trace.
         * <p/>
         * IMPORTANT NOTE: {@link Span}s are not allowed to have a null trace ID, so if this is null when {@link #build()} is called then the {@link Span} returned by
         *                 {@link #build()} will have its trace ID defaulted to a new random ID using {@link TraceAndSpanIdGenerator#generateId()}.
         *
         * @param traceId the {@code traceId} to set
         * @return a reference to this Builder
         */
        public Builder withTraceId(String traceId) {
            this.traceId = traceId;
            return this;
        }

        /**
         * Sets the ID for this span of work in the distributed trace. Don't confuse this with {@link #withTraceId(String)}, which sets the ID associated with the overall
         * distributed trace and is the same for all spans in a trace. Also don't confuse this with {@link #getParentSpanId()}, which is the ID of the span that spawned
         * this span instance (the logical "parent" of this span).
         * <p/>
         * IMPORTANT NOTE: {@link Span}s are not allowed to have a null span ID, so if this is null when {@link #build()} is called then the {@link Span} returned by
         *                 {@link #build()} will have its span ID defaulted to a new random ID using {@link TraceAndSpanIdGenerator#generateId()}.
         *
         * @param spanId the {@code spanId} to set
         * @return a reference to this Builder
         */
        public Builder withSpanId(String spanId) {
            this.spanId = spanId;
            return this;
        }

        /**
         * Sets the ID of the span that spawned this span instance (the logical "parent" of this span), or pass in null if no such parent exists. If you pass in null then
         * this instance will be a root span for the distributed trace - the ultimate ancestor of all other spans in the trace tree.
         *
         * @param parentSpanId the {@code parentSpanId} to set
         * @return a reference to this Builder
         */
        public Builder withParentSpanId(String parentSpanId) {
            this.parentSpanId = parentSpanId;
            return this;
        }

        /**
         * Sets the human-readable name for this span. This should never be null - if you set this to null and call {@link #build()} then an {@link IllegalArgumentException} will
         * be thrown.
         *
         * @param spanName the {@code spanName} to set
         * @return a reference to this Builder
         */
        public Builder withSpanName(String spanName) {
            this.spanName = spanName;
            return this;
        }

        /**
         * Set this to true if this span is sampleable and should be output to the logging/span collection system, false otherwise. This defaults to true.
         *
         * @param sampleable the {@code sampleable} value to set
         * @return a reference to this Builder
         */
        public Builder withSampleable(boolean sampleable) {
            this.sampleable = sampleable;
            return this;
        }

        /**
         * Sets the ID of the user logically associated with this span, or pass in null if no such user ID exists or is appropriate.
         *
         * @param userId the {@code userId} to set
         * @return a reference to this Builder
         */
        public Builder withUserId(String userId) {
            this.userId = userId;
            return this;
        }

        /**
         * Sets the start time of the span in nanoseconds. This is used when calculating {@link #getTimeSpentNanos()} - see that method for more details.
         * <p/>
         * IMPORTANT NOTE: {@link Span}s are not allowed to have a null start time, so if this is null when {@link #build()} is called then the {@link Span} returned by
         *                 {@link #build()} will have its start time defaulted to {@link System#nanoTime()}.
         *
         * @param spanStartTimeNanos the {@code spanStartTimeNanos} to set
         * @return a reference to this Builder
         */
        public Builder withSpanStartTimeNanos(Long spanStartTimeNanos) {
            this.spanStartTimeNanos = spanStartTimeNanos;
            return this;
        }

        /**
         * Sets the end time of the span in nanoseconds, or null if this {@link Span} should not be considered {@link Span#isCompleted()} yet.
         * This is used when calculating {@link #getTimeSpentNanos()} - see that method for more details.
         * <p/>
         * NOTE: Under most circumstances you will want this to be null (which is the default) since there are not many use cases where you need to create an
         * already-completed {@link Span}.
         *
         * @param spanEndTimeNanos the {@code spanEndTimeNanos} to set
         * @return a reference to this Builder
         */
        public Builder withSpanEndTimeNanos(Long spanEndTimeNanos) {
            this.spanEndTimeNanos = spanEndTimeNanos;
            return this;
        }

        /**
         * Returns a {@link Span} built from the parameters set via the various {@code with*(...)} methods on this builder instance.
         * <p/>
         * IMPORTANT NOTE: {@link Span} objects are not allowed to have null {@link Span#getTraceId()}, {@link Span#getSpanId()}, or {@link Span#getSpanStartTimeNanos()},
         *                 and there are sensible defaults we can set for those values, so if any of them are null when this method is called they will be set to the following:
         *                 <ul>
         *                     <li>{@code traceId} is defaulted to {@link TraceAndSpanIdGenerator#generateId()}</li>
         *                     <li>{@code spanId} is defaulted to {@link TraceAndSpanIdGenerator#generateId()}</li>
         *                     <li>{@code spanStartTimeNanos} is defaulted to {@link System#nanoTime()}</li>
         *                 </ul>
         *                 Span name is also not allowed to be null, but since there is no sensible default for that value an {@link IllegalArgumentException} will be thrown
         *                 if span name is null when this method is called.
         *
         * @return a {@code Span} built with parameters of this {@code Span.Builder}
         */
        public Span build() {
            if (traceId == null)
                traceId = TraceAndSpanIdGenerator.generateId();

            if (spanId == null)
                spanId = TraceAndSpanIdGenerator.generateId();

            if (spanStartTimeNanos == null)
                spanStartTimeNanos = System.nanoTime();

            return new Span(traceId, parentSpanId, spanId, spanName, sampleable, userId, spanStartTimeNanos, spanEndTimeNanos);
        }
    }
}
